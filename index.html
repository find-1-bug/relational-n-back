<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Relational N-Back — Dynamic Relation Buttons</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0f1220;
      --panel:#171b2e;
      --muted:#7e86a3;
      --text:#eef2ff;
      --accent:#5ee1a2;
      --accent-2:#77b5ff;
      --warn:#ffb454;
      --danger:#ff6b6b;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,Apple Color Emoji,Segoe UI Emoji;
      color:var(--text);
      background: radial-gradient(1200px 700px at 10% -10%, #1b2140 0%, var(--bg) 45%), linear-gradient(180deg, #101428, #0b0e1b);
      display:flex; flex-direction:column; align-items:center;
    }
    header{
      width:100%; max-width:1100px; padding:18px 20px; display:flex; gap:16px; align-items:center; justify-content:space-between;
    }
    header h1{font-size:20px; margin:0; letter-spacing:0.3px}
    header .links{display:flex; gap:10px; align-items:center}
    .chip{
      font-size:12px; color:var(--muted); padding:6px 10px; border:1px solid #283054; border-radius:999px; text-decoration:none;
      display:inline-flex; align-items:center; gap:6px; background:#12162a99; backdrop-filter: blur(6px);
    }
    .container{
      width:100%; max-width:1100px; padding:0 20px 30px; display:grid; grid-template-columns: 340px 1fr; gap:20px;
    }
    @media (max-width: 960px){
      .container{grid-template-columns:1fr; padding:0 10px 80px;}
    }
    .card{
      background:linear-gradient(180deg, #151a33, #11162c);
      border:1px solid #262c4a;
      border-radius:14px;
      box-shadow: 0 10px 24px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.03);
      overflow:hidden;
    }
    .card h2{
      margin:0; padding:14px 16px; font-size:14px; text-transform:uppercase; letter-spacing:1.2px; color:#b9c3ea;
      border-bottom:1px solid #262c4a; background:#121733;
    }
    .card .content{padding:14px 16px}
    .grid{display:grid; gap:8px;}
    .grid.cols-2{grid-template-columns:1fr 1fr}
    label{font-size:12px; color:#b6bdd9; display:block; margin-bottom:6px;}
    input[type="number"], select, input[type="text"]{
      width:100%; padding:10px 12px; background:#0e1230; color:var(--text);
      border:1px solid #2c375f; border-radius:10px; outline:none; word-break:break-all;
    }
    input[type="range"]{width:100%}
    .row{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    .hint{font-size:12px; color:#b6bdd9}
    .switch{display:inline-flex; align-items:center; gap:10px; cursor:pointer; user-select:none; font-size:13px; color:#d7defa; min-width:160px;}
    .switch input{display:none}
    .toggle{
      width:44px; height:24px; background:#0e1230; border:1px solid #2c375f; border-radius:999px; position:relative; transition:.2s ease all; flex-shrink:0;
    }
    .toggle::after{
      content:""; width:18px; height:18px; background:#dfe7ff; border-radius:50%;
      position:absolute; top:2px; left:2px; transition:.2s ease all; box-shadow: 0 2px 6px rgba(0,0,0,0.35);
    }
    .switch input:checked + .toggle{background:linear-gradient(90deg, var(--accent-2), var(--accent)); border-color:transparent;}
    .switch input:checked + .toggle::after{left:24px; background:#0b1330}
    .stage{min-height:560px; display:grid; grid-template-rows: auto auto 1fr auto; gap:14px; padding:16px;}
    .statusbar{
      display:grid; grid-template-columns: 1fr auto auto auto auto; gap:8px; align-items:center;
      font-size:13px; color:#c9d2ff;
    }
    .statusbar .badge{
      padding:6px 10px; border:1px solid #2b3561; border-radius:10px; background:#0e1331; color:#cfe4ff;
    }
    .stimulus-area{
      display:grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap:12px; justify-content:center; align-content:center; padding:8px 0; max-width:min(90vw, 360px); margin:0 auto;
      aspect-ratio:1; padding-inline: clamp(8px, 3vw, 16px);
    }
    .cell{
      border-radius:12px; background:transparent; border:1px solid #ffffff; display:flex; align-items:center; justify-content:center;
      position:relative; overflow:hidden; aspect-ratio:1/1;
    }
    .cell.active{
      outline:2px solid var(--accent);
      box-shadow: 0 0 0 6px rgba(94,225,162,0.12) inset, 0 0 30px rgba(94,225,162,0.25);
    }
    .relation-bar{display:flex; flex-wrap:wrap; gap:8px; justify-content:center; padding:6px 0 2px;}
    .rel-btn{
      padding:10px 12px; border-radius:12px; background:#0f1334; border:1px solid #2b3561; color:#dbe5ff;
      font-weight:600; font-size:13px; letter-spacing:0.2px; cursor:pointer; transition:.15s ease all;
      display:inline-flex; align-items:center; gap:8px; user-select:none; position:relative;
    }
    .rel-btn .sub{
      position:absolute; top:-10px; left:50%; transform:translate(-50%,-100%);
      background:#0b102b; border:1px solid #2a3560; padding:3px 8px; border-radius:8px; font-size:11px; color:#9fb4ff; opacity:.9;
    }
    .rel-btn.kbd::before,
    .btn.kbd::before{
      content:attr(data-key);
      font-weight:700; font-size:11px; background:#0b102b; border:1px solid #2a3560; color:#9fb4ff; padding:3px 6px; border-radius:6px;
    }
    .rel-btn:hover{transform:translateY(-1px); border-color:#3a4782}
    .rel-btn:active{transform:translateY(0)}
    .rel-btn.matching{
      background:linear-gradient(180deg, rgba(94,225,162,0.15), rgba(94,225,162,0.06));
      border-color:#3a6c58; color:#dff9ee;
    }
    .rel-btn.pending{animation: pulse 1.1s ease-in-out infinite}
    @keyframes pulse{0%,100%{box-shadow:0 0 0 rgba(94,225,162,0)} 50%{box-shadow: 0 0 0 8px rgba(94,225,162,0.08)}}
    .controls{display:flex; flex-wrap:wrap; gap:10px; justify-content:center; padding:8px 0 4px;}
    .btn{padding:10px 14px; border-radius:12px; border:1px solid #2b3561; background:#0e1331; color:#dbe5ff; cursor:pointer; font-weight:700;}
    .btn.primary{background:linear-gradient(180deg, #2a5cff, #1b3cc9); border-color:#2a5cff; box-shadow: 0 8px 20px rgba(42,92,255,0.25);}
    .btn.ghost{background:#0e1331}
    .btn.warn{background:linear-gradient(180deg, #ff9a5c, #f0722e); border-color:#ff9a5c}
    .btn:disabled{opacity:.5; cursor:not-allowed}
    .log{
      height:100px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background:#0b102a; border:1px dashed #2b3561; border-radius:10px; padding:10px; color:#b6c3ff; font-size:12px; overflow-y:auto;
    }
    .legend{font-size:12px; color:#9fb4ff; text-align:center}
    .bar{height:8px; background:#0b102a; border:1px solid #2b3561; border-radius:999px; overflow:hidden;}
    .bar > .fill{height:100%; width:0%; background:linear-gradient(90deg, var(--accent-2), var(--accent))}
    .pill{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:#0f1433; border:1px solid #2b3561; color:#cfe4ff; font-size:12px;}
    .kbd{font-weight:700; font-size:11px; background:#0b102b; border:1px solid #2a3560; color:#9fb4ff; padding:3px 6px; border-radius:6px;}
    footer{opacity:.85; padding:10px; font-size:12px; color:#95a5d6}
    a { color:#9ec5ff; text-decoration:none }
    a:hover{text-decoration:underline}
    .tiny{font-size:11px; color:#a8b6ff}
    .sep{opacity:.5; margin:0 6px}
    .metrics{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace; font-size:12px; color:#cfe4ff; background:#0b102a; border:1px dashed #2b3561; border-radius:10px; padding:8px;}
    @media (max-width: 600px) {
      .manual-controls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--bg);
        padding: 10px;
        display: flex;
        justify-content: center;
        gap: 10px;
        border-top: 1px solid #262c4a;
        z-index: 10;
      }
      .controls .manual-controls button { flex: 1; }
      .stimulus-area { max-width:100%; gap:8px; }
      .cell .dot { width: 80%; height: 80%; }
      .cell > div { max-width: 80%; max-height: 80%; }
    }
  </style>
  <meta name="description" content="Relational N-Back trainer with dynamic relation prompts on classic modality buttons. Position SameRow/SameCol/Closer/Farther, Sound Before/Same/After, Color Same/Opposite (true complement), Shape Fewer/Same/More sides." />
  <meta name="theme-color" content="#0f1220" />
  <script type="importmap">
  {
    "imports": {
      "seedrandom": "https://cdn.jsdelivr.net/npm/seedrandom@3.0.5/+esm"
    }
  }
  </script>
</head>
<body>
  <header>
    <h1>Relational N-Back — Dynamic Relation Buttons</h1>
    <div class="links">
      <span class="chip">Refs:
        <a class="chip" href="https://brainscale.net/app/dual-n-back/training" target="_blank" rel="noopener">brainscale.net</a>
        <a class="chip" href="https://4skinskywalker.github.io/Lite-Dual_N-back/Dichotic_Dual_N-back/" target="_blank" rel="noopener">4skinskywalker.github.io</a>
        <a class="chip" href="https://dev.to/michael_02910bc84e622d090/relational-n-back-4834" target="_blank" rel="noopener">dev.to</a>
      </span>
    </div>
  </header>
  <div class="container">
    <section class="card">
      <h2>Session Setup</h2>
      <div class="content grid">
        <div class="grid cols-2">
          <div>
            <label for="nLevel">N-back level</label>
            <input id="nLevel" type="number" min="1" max="9" value="1" />
          </div>
          <div>
            <label for="stimMs">Stimulus time (ms)</label>
            <input id="stimMs" type="number" min="300" step="50" value="1300" />
          </div>
          <div>
            <label for="isiMs">ISI / Gap (ms)</label>
            <input id="isiMs" type="number" min="0" step="50" value="300" />
          </div>
          <div>
            <label for="len">Sequence length</label>
            <input id="len" type="number" min="10" max="300" value="24" />
          </div>
        </div>
        <div class="grid cols-2">
          <div>
            <label>Active modalities</label>
            <div class="row">
              <label class="switch" title="Position modality">
                <input id="mod-position" type="checkbox" checked />
                <span class="toggle"></span>
                Position
              </label>
            </div>
            <div class="row">
              <label class="switch" title="Sound modality">
                <input id="mod-sound" type="checkbox" checked />
                <span class="toggle"></span>
                Sound
              </label>
            </div>
            <div class="row">
              <label class="switch" title="Color modality">
                <input id="mod-color" type="checkbox" checked />
                <span class="toggle"></span>
                Color
              </label>
            </div>
            <div class="row">
              <label class="switch" title="Shape modality">
                <input id="mod-shape" type="checkbox" checked />
                <span class="toggle"></span>
                Shape
              </label>
            </div>
            <!-- COMPOSITE MODALITY: toggle -->
            <div class="row">
              <label class="switch" title="Composite modality: logical reduction over current & previous n trials of other active modalities">
                <input id="mod-composite" type="checkbox" />
                <span class="toggle"></span>
                Composite
              </label>
            </div>
            <!-- END COMPOSITE -->
          </div>
          <div>
            <label for="matchRatio">Prompt-true ratio (%)</label>
            <input id="matchRatio" type="number" min="10" max="90" value="33" />
          </div>
        </div>
        <div class="grid cols-2">
          <div>
            <label for="lurePct">Lure trials (%)</label>
            <input id="lurePct" type="number" min="0" max="70" value="45" />
          </div>
          <div class="row">
            <label class="switch" title="Random jitter on stimulus and gap times">
              <input id="jitterOn" type="checkbox" checked />
              <span class="toggle"></span>
              Jitter timing
            </label>
          </div>
        </div>
        <div class="grid cols-2">
          <div class="row">
            <label class="switch" title="Flip button prompt to currently requested relation; press only if true vs N-back.">
              <input id="dynamicLabels" type="checkbox" checked />
              <span class="toggle"></span>
              Dynamic prompts on buttons
            </label>
          </div>
          <div class="row">
            <label class="switch" title="Only accept responses during the stimulus window.">
              <input id="strictWindow" type="checkbox" />
              <span class="toggle"></span>
              Strict response window
            </label>
          </div>
        </div>
        <div class="grid cols-2">
          <div class="row">
            <label class="switch" title="Auto adjust N using a staircase based on per-modality d′ and FA rate">
              <input id="adaptiveOn" type="checkbox" />
              <span class="toggle"></span>
              Adaptive N
            </label>
          </div>
          <div class="row">
            <label class="switch" title="Play procedural tones for feedback.">
              <input id="soundOn" type="checkbox" checked />
              <span class="toggle"></span>
              Sound on
            </label>
          </div>
        </div>
        <div class="grid cols-2">
          <div class="row">
            <label class="switch" title="Announce stimuli via voice for accessibility (position, sound, color, shape).">
              <input id="voiceOn" type="checkbox" />
              <span class="toggle"></span>
              Voice cues
            </label>
          </div>
          <div class="row">
            <label class="switch" title="Use grayscale for colors (disable 'color' modality for full effect).">
              <input id="colorblind" type="checkbox" />
              <span class="toggle"></span>
              Colorblind mode
            </label>
          </div>
        </div>
        <div class="grid cols-2">
          <div class="row">
            <label class="switch" title="Show visual feedback for correct answers.">
              <input id="showFeedback" type="checkbox" checked />
              <span class="toggle"></span>
              Show feedback
            </label>
          </div>
        </div>
        <div class="row">
          <span class="pill">Keys: 1..9 = modality buttons, N = No match, Space = Start/Stop</span>
        </div>
        <div class="controls">
          <button id="startBtn" class="btn primary">Start</button>
          <button id="stopBtn" class="btn ghost" disabled>Stop</button>
          <button id="undoBtn" class="btn ghost" disabled>Undo</button>
          <button id="seedBtn" class="btn ghost" title="Regenerate sequence with new seed">Reseed</button>
          <button id="exportBtn" class="btn ghost">Export Log</button>
          <button id="resetBtn" class="btn warn">Reset Settings</button>
        </div>
        <div class="controls manual-controls">
          <button id="backBtn" class="btn ghost" title="Go to previous stimulus in manual mode (review only; no scoring).">Back</button>
          <button id="stepBtn" class="btn ghost" title="Advance one stimulus without timer; useful for testing.">Step</button>
        </div>
        <div class="grid">
          <div class="row">
            <div class="hint">Progress</div>
            <div class="hint" id="progressText">0 / 24</div>
          </div>
          <div class="bar"><div id="progressBar" class="fill"></div></div>
        </div>
      </div>
    </section>
    <section class="card stage">
      <div class="statusbar">
        <div class="badge">N=<span id="nLabel">1</span></div>
        <div class="badge">Score <span id="score">0</span></div>
        <div class="badge">Acc <span id="acc">100%</span></div>
        <div class="badge">Streak <span id="streak">0</span></div>
        <div class="badge">Trials <span id="trialCounter">0</span></div>
      </div>
      <div class="legend">
        Relational twist: Each modality’s button shows a prompt. Press it only if TRUE vs N-back.
        Position relations: Equal / SameRow / SameCol / Closer / Farther.
      </div>
      <div id="stimArea" class="stimulus-area" aria-live="polite" aria-atomic="true"></div>
      <div class="relation-bar" id="relationBar"></div>
      <div class="controls">
        <button id="passBtn" class="btn kbd" data-key="N">No match</button>
        <button id="hintBtn" class="btn">Peek</button>
        <button id="repeatBtn" class="btn">Repeat Stimulus</button>
        <button id="clearBtn" class="btn warn">Clear Prompts</button>
      </div>
      <div id="log" class="log"></div>
      <div id="metrics" class="metrics"></div>
      <div class="tiny" style="text-align:center; padding-bottom:8px">
        Grid index: 1..3 top row, 4..6 middle, 7..9 bottom. Sound A..E. Color uses true hue complement for “Opposite”.
        Shape relation is on sides: Fewer / Same / More. (Colorblind mode uses grayscale.)
      </div>
    </section>
  </div>
  <footer>
    Inspired by established dual n-back UX patterns such as brainscale.net and community adaptations like 4skinskywalker’s dichotic version. A relational variant has been discussed in community posts (e.g., dev.to). Improved with accessibility features.
  </footer>
  <div id="ariaAnnounce" aria-live="assertive" style="position:absolute; width:1px; height:1px; overflow:hidden; clip: rect(0,0,0,0);"></div>
  <div id="helpOverlay" style="display:none; position:fixed; top:20%; left:20%; right:20%; bottom:20%; background:var(--panel); border:1px solid #00000055; border-radius:14px; padding:20px; z-index:20; overflow:auto;">
    <h2>Help & Examples</h2>
    <p>Keyboard shortcuts: 1-4 for modality buttons, N for No match, Space to start/stop, ? to toggle this help.</p>
    <p>Example: For "Position" with prompt "SameRow", press the Position button if the current position is in the same row as the N-back position.</p>
    <p>Example: For "Color" with prompt "Opposite", press if the current color is the perceptual opposite of the N-back color.</p>
    <p>Example: For "Shape" with prompt "More", press if the current shape has more sides than the N-back one.</p>
    <!-- COMPOSITE help -->
    <p><b>Composite:</b> The button shows XOR/OR/AND/NAND. It evaluates the logical reduction of
      the “any-true” condition across the current and previous <em>n</em> trials of the other active modalities.
      Press only if that reduction is TRUE.</p>
    <!-- END COMPOSITE help -->
    <button onclick="this.parentNode.style.display='none'">Close</button>
  </div>
  <script type="module">
    import seedrandom from "seedrandom";
    // Seeded RNG
    let rng = seedrandom(String(Date.now()));
    const reseed = (seed) => { state.seed = seed ?? Date.now(); rng = seedrandom(String(state.seed)); };
    const R = (n)=>Math.floor(rng()*n);
    const pick = (arr)=>arr[R(arr.length)];
    const balancedPick = (arr, len) => {
      let res = [];
      while(res.length < len){
        res.push(...shuffle([...arr]));
      }
      return res.slice(0,len);
    };
    // DOM helpers
    const $ = (s, r=document) => r.querySelector(s);
    const $$ = (s, r=document) => Array.from(r.querySelectorAll(s));
    const logEl = $("#log");
    const log = (msg)=>{ const t = new Date().toLocaleTimeString(); logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent; };
    const metricsEl = $("#metrics");
    const ariaAnnounce = $("#ariaAnnounce");
    // Procedural audio
    const audio = new (window.AudioContext || window.webkitAudioContext)();
    function tone(freq=440, dur=0.12, type="sine", gain=0.06){
      const t0 = audio.currentTime + 0.01;
      const t1 = t0 + dur;
      const o = audio.createOscillator();
      const g = audio.createGain();
      o.type = type; o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(gain, t0+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t1);
      o.connect(g).connect(audio.destination);
      o.start(t0); o.stop(t1+0.02);
    }
    const sfx = {
      ok: ()=>{ tone(660, 0.08, "triangle", 0.04); tone(990, 0.08, "triangle", 0.03) },
      err: ()=>{ tone(180, 0.12, "sawtooth", 0.05) },
      tick: ()=>{ tone(420, 0.04, "square", 0.03) },
      cue: ()=>{ tone(520, 0.06, "sine", 0.03) }
    };
    // Stimulus domains
    const GRID_POS = [
      [0,0],[1,0],[2,0],
      [0,1],[1,1],[2,1],
      [0,2],[1,2],[2,2]
    ];
    const posIndex = (xy)=> xy[1]*3 + xy[0] + 1; // 1..9
    const centerDist = (xy)=> Math.hypot(xy[0]-1, xy[1]-1);
    const LETTERS = ["A","B","C","D","E"];
    // Color-blind safe palette (deuteranomaly-friendly)
    let COLORS = ["#e69f00", "#56b4e9", "#009e73", "#f0e442", "#0072b2"];
    // HSL helpers for true complement and near hues (for lures)
    function hexToHsl(hex){
      const r=parseInt(hex.slice(1,3),16)/255, g=parseInt(hex.slice(3,5),16)/255, b=parseInt(hex.slice(5,7),16)/255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b); let h=0, s=0, l=(max+min)/2;
      if(max!==min){
        const d=max-min;
        s = l>0.5 ? d/(2-max-min) : d/(max+min);
        switch(max){
          case r: h=(g-b)/d+(g<b?6:0); break;
          case g: h=(b-r)/d+2; break;
          default: h=(r-g)/d+4;
        }
        h*=60;
      }
      return {h,s,l};
    }
    function hslToHex({h,s,l}){
      const C=(1-Math.abs(2*l-1))*s, X=C*(1-Math.abs((h/60)%2-1)), m=l-C/2;
      let r=0,g=0,b=0;
      if(h<60){[r,g,b]=[C,X,0]}
      else if(h<120){[r,g,b]=[X,C,0]}
      else if(h<180){[r,g,b]=[0,C,X]}
      else if(h<240){[r,g,b]=[0,X,C]}
      else if(h<300){[r,g,b]=[X,0,C]}
      else {[r,g,b]=[C,0,X]}
      const toHex=v=>Math.round((v+m)*255).toString(16).padStart(2,"0");
      return "#"+toHex(r)+toHex(g)+toHex(b);
    }
    const complementHex = (hex)=>{
      const hsl = hexToHsl(hex);
      if($("#colorblind").checked) {
        return hsl.l > 0.5 ? "#333333" : "#ffffff";
      }
      return hslToHex({h:(hsl.h+180)%360, s:hsl.s, l:hsl.l});
    };
    const nearHue = (hex)=>{
      const hsl = hexToHsl(hex);
      if($("#colorblind").checked) {
        return hsl.l > 0.5 ? "#666666" : "#999999"; // mid greys for lures
      } else {
        let delta = pick([-20,-15,15,20]);
        let newH = (hsl.h + delta + 360) % 360;
        while (Math.abs(newH - hsl.h) < 5 || Math.abs(newH - ((hsl.h + 180) % 360)) < 5) {
          delta = pick([-20,-15,15,20]);
          newH = (hsl.h + delta + 360) % 360;
        }
        return hslToHex({h: newH, s: hsl.s, l: hsl.l});
      }
    };
    const SHAPES = ["circle","triangle","square"];
    const NUM_SIDES = {circle: 0, triangle: 3, square: 4};
    // Relation prompts per modality
    const PROMPTS = {
      position: ["Equal","SameRow","SameCol","Closer","Farther"],
      sound: ["Before","Same","After"],
      color: ["Same","Opposite"],
      shape: ["Fewer","Same","More"],
      // COMPOSITE MODALITY: operator prompts
      composite: ["XOR","OR","AND","NAND"]
      // END COMPOSITE
    };
    // Evaluate if the prompt is true
    const Eval = {
      position: (prompt, cur, prev)=>{
        if(!prev) return false;
        if(prompt==="Equal") return cur[0]===prev[0] && cur[1]===prev[1];
        if(prompt==="SameRow") return cur[1]===prev[1];
        if(prompt==="SameCol") return cur[0]===prev[0];
        if(prompt==="Closer") return centerDist(cur) < centerDist(prev);
        if(prompt==="Farther") return centerDist(cur) > centerDist(prev);
        return false;
      },
      sound: (prompt, cur, prev)=>{
        if(!prev) return false;
        const a = LETTERS.indexOf(cur), b = LETTERS.indexOf(prev);
        if(prompt==="Same") return a===b;
        if(prompt==="Before") return a<b;
        if(prompt==="After") return a>b;
        return false;
      },
      color: (prompt, cur, prev)=>{
        if(!prev) return false;
        if(prompt==="Same") return cur.toLowerCase() === prev.toLowerCase();
        if(prompt==="Opposite") return cur.toLowerCase() === complementHex(prev).toLowerCase();
        return false;
      },
      shape: (prompt, cur, prev)=>{
        if(!prev) return false;
        const a = NUM_SIDES[cur], b = NUM_SIDES[prev];
        if(prompt==="Same") return a===b;
        if(prompt==="Fewer") return a<b;
        if(prompt==="More") return a>b;
        return false;
      },
      // COMPOSITE MODALITY: dynamic evaluation
      // At trial i, take booleans B_t = "any relation true among non-composite active modalities" for t in [i, i-1, ..., i-n]
      // Reduce B_t with the chosen operator (prompt): XOR / OR / AND / NAND
      composite: (operatorPrompt, i, n, baseRelations)=>{
        if(i < n) return false; // need full history window
        // Build window of booleans across time using only base relations (exclude composite)
        const window = [];
        for(let k=0; k<=n; k++){
          const t = i - k;
          const anyTrueAtT = baseRelations.some(rel=>{
            const p = state.prompts[rel]?.[t];
            if(!p) return false;
            const cur = state.seq[t]?.[rel];
            const prev = state.seq[t-n]?.[rel]; // always compare vs N-back (same N)
            return Eval[rel](p, cur, prev);
          });
          window.push(anyTrueAtT);
        }
        // Reduce with operator
        let result = false;
        if(operatorPrompt === "OR"){
          result = window.some(Boolean);
        } else if(operatorPrompt === "AND"){
          result = window.every(Boolean);
        } else if(operatorPrompt === "XOR"){
          const count = window.reduce((acc,b)=> acc + (b?1:0), 0);
          result = (count % 2) === 1;
        } else if(operatorPrompt === "NAND"){
          result = !window.every(Boolean);
        }
        return result;
      }
      // END COMPOSITE
    };
    // Generate one multi-attribute stimulus
    function generateItem(){
      return {
        position: pick(GRID_POS),
        sound: pick(LETTERS),
        color: pick(COLORS),
        shape: pick(SHAPES)
        // composite has no physical stimulus
      };
    }
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(rng()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
    // Adjust current item to satisfy TRUE/LURE/FOIL relative to back item for the given prompt
    function adjustStimulusForRole(rel, prompt, cur, back, role){
      if(rel==="position"){
        const neighbors = GRID_POS.filter(xy => (xy[0]===back.position[0] || xy[1]===back.position[1]) && !(xy[0]===back.position[0] && xy[1]===back.position[1]));
        const far = GRID_POS.filter(xy => xy[0]!==back.position[0] && xy[1]!==back.position[1]);
        if(role==="TRUE"){
          if(prompt==="Equal") cur.position = back.position;
          if(prompt==="SameRow") cur.position = pick(GRID_POS.filter(xy => xy[1]===back.position[1] && !(xy[0]===back.position[0] && xy[1]===back.position[1]))) || cur.position;
          if(prompt==="SameCol") cur.position = pick(GRID_POS.filter(xy => xy[0]===back.position[0] && !(xy[0]===back.position[0] && xy[1]===back.position[1]))) || cur.position;
          if(prompt==="Closer") cur.position = pick(GRID_POS.filter(xy => centerDist(xy) < centerDist(back.position))) || cur.position;
          if(prompt==="Farther") cur.position = pick(GRID_POS.filter(xy => centerDist(xy) > centerDist(back.position))) || cur.position;
        }else if(role==="LURE"){
          if(prompt==="Equal") cur.position = pick(neighbors.length? neighbors : far);
          if(prompt==="SameRow") cur.position = pick(GRID_POS.filter(xy => xy[0]===back.position[0])) || cur.position;
          if(prompt==="SameCol") cur.position = pick(GRID_POS.filter(xy => xy[1]===back.position[1])) || cur.position;
          if(prompt==="Closer") cur.position = pick(GRID_POS.filter(xy => centerDist(xy) > centerDist(back.position))) || cur.position;
          if(prompt==="Farther") cur.position = pick(GRID_POS.filter(xy => centerDist(xy) < centerDist(back.position))) || cur.position;
        }else{
          cur.position = pick(far.length? far : GRID_POS.filter(xy => !(xy[0]===back.position[0] && xy[1]===back.position[1])));
        }
      } else if(rel==="sound"){
        const bi = LETTERS.indexOf(back.sound);
        const before = LETTERS.slice(0, bi);
        const after = LETTERS.slice(bi+1);
        const adj = LETTERS.filter((_,i)=> Math.abs(i-bi)===1);
        const far = LETTERS.filter((_,i)=> Math.abs(i-bi)>=2);
        if(role==="TRUE"){
          if(prompt==="Same") cur.sound = back.sound;
          if(prompt==="Before" && before.length) cur.sound = pick(before);
          if(prompt==="After" && after.length) cur.sound = pick(after);
        }else if(role==="LURE"){
          cur.sound = pick(adj.length? adj : LETTERS.filter(s=>s!==back.sound));
          if(prompt==="Same" && cur.sound===back.sound){ cur.sound = pick(far.length? far : adj); }
          if(prompt==="Before" && !(LETTERS.indexOf(cur.sound)<bi)) cur.sound = back.sound;
          if(prompt==="After" && !(LETTERS.indexOf(cur.sound)>bi)) cur.sound = back.sound;
        }else{
          cur.sound = pick(far.length? far : LETTERS.filter(s=>s!==back.sound));
        }
      } else if(rel==="color"){
        if($("#colorblind").checked){
          if(role==="TRUE"){
            if(prompt==="Same") cur.color = back.color;
            if(prompt==="Opposite") cur.color = complementHex(back.color);
          } else {
            if(prompt==="Same") cur.color = complementHex(back.color);
            if(prompt==="Opposite") cur.color = back.color;
          }
          return;
        }
        if(role==="TRUE"){
          if(prompt==="Same") cur.color = back.color;
          if(prompt==="Opposite") cur.color = complementHex(back.color);
        }else if(role==="LURE"){
          cur.color = nearHue(back.color);
          if(prompt==="Opposite" && cur.color.toLowerCase()===complementHex(back.color).toLowerCase()){
            cur.color = nearHue(back.color);
          }
          if(prompt==="Same" && cur.color.toLowerCase()===back.color.toLowerCase()){
            cur.color = nearHue(back.color);
          }
        }else{
          cur.color = pick(COLORS.filter(c => c !== back.color && c !== complementHex(back.color)));
        }
      } else if(rel==="shape"){
        const b = NUM_SIDES[back.shape];
        const fewer = SHAPES.filter(s=> NUM_SIDES[s]<b);
        const more = SHAPES.filter(s=> NUM_SIDES[s]>b);
        const adj = SHAPES.filter(s=> Math.abs(NUM_SIDES[s]-b)===1 || Math.abs(NUM_SIDES[s]-b)===3); // circle-triangle diff=3
        const far = SHAPES.filter(s=> Math.abs(NUM_SIDES[s]-b)>=3 && s!==back.shape);
        if(role==="TRUE"){
          if(prompt==="Same") cur.shape = back.shape;
          if(prompt==="Fewer") cur.shape = fewer.length? pick(fewer) : back.shape;
          if(prompt==="More") cur.shape = more.length? pick(more) : back.shape;
        }else if(role==="LURE"){
          cur.shape = adj.length? pick(adj) : (far.length ? pick(far) : back.shape);
          if(prompt==="Same" && cur.shape===back.shape){
            cur.shape = adj.length? pick(adj) : far.length ? pick(far) : back.shape;
          }
        }else{
          cur.shape = far.length ? pick(far) : adj.length ? pick(adj) : back.shape;
        }
      }
      // NOTE: composite has no stimulus to adjust
    }
    // For each modality, generate prompt schedule and assign TRUE/LURE/FOIL roles
    function generatePromptsAndAdjust(seq, relations, n, truePct, lurePct){
      const prompts = {};
      const T = seq.length;
      const candidateIdxs = Array.from({length: T - n}, (_,k)=> k + n);

      relations.forEach(rel=>{
        // COMPOSITE: we only need operator prompts; no stimulus adjustment or roles
        if(rel === "composite"){
          const ops = balancedPick(PROMPTS.composite, T);
          prompts[rel] = ops;
          // Attach a synthetic role for logging consistency
          for(const i of candidateIdxs){
            const cur = seq[i];
            cur._trial = cur._trial || {};
            cur._trial[rel] = {prompt: ops[i], role: "DERIVED"};
          }
          return;
        }
        // Non-composite (original behavior)
        const p = balancedPick(PROMPTS[rel], T);
        const idxs = candidateIdxs.slice(); shuffle(idxs);
        const numTrue = Math.round(idxs.length * (truePct/100));
        const numLure = Math.round(idxs.length * (lurePct/100));
        const trueIdxs = new Set(idxs.slice(0, numTrue));
        const lureIdxs = new Set(idxs.slice(numTrue, numTrue + numLure));
        for(const i of candidateIdxs){
          const back = seq[i-n];
          const cur = seq[i];
          const prompt = p[i];
          const role = trueIdxs.has(i) ? "TRUE" : lureIdxs.has(i) ? "LURE" : "FOIL";
          adjustStimulusForRole(rel, prompt, cur, back, role);
          cur._trial = cur._trial || {};
          cur._trial[rel] = {prompt, role};
        }
        prompts[rel] = p;
      });

      // Add multiTrue flag (counts only non-composite TRUES)
      for(const i of candidateIdxs){
        const nonComp = relations.filter(r => r !== "composite");
        const countTrue = nonComp.filter(rel => seq[i]._trial[rel].role === "TRUE").length;
        seq[i].multiTrue = countTrue > 1;
      }
      return prompts;
    }
    // UI build: 3x3 grid
    const stimArea = $("#stimArea");
    const cells = [];
    for(let y=0;y<3;y++){
      for(let x=0;x<3;x++){
        const d = document.createElement("div");
        d.className="cell";
        d.dataset.x = x; d.dataset.y = y;
        d.setAttribute("aria-label", `Cell at row ${y+1}, column ${x+1}`);
        cells.push(d);
        stimArea.appendChild(d);
      }
    }
    function clearCells(){
      cells.forEach(c=>{ c.classList.remove("active"); c.innerHTML=""; });
    }
    function drawStimulus(item){
      clearCells();
      const [px,py] = item.position;
      const cell = cells.find(c => Number(c.dataset.x)===px && Number(c.dataset.y)===py);
      if(!cell) return;
      cell.classList.add("active");
      // Draw shape with color
      let sz = 60;
      let color = item.color;
      if($("#colorblind").checked){
        color = color;
      }
      const shapeContainer = document.createElement("div");
      shapeContainer.style.width = sz + "px";
      shapeContainer.style.height = sz + "px";
      shapeContainer.style.display = "flex";
      shapeContainer.style.alignItems = "center";
      shapeContainer.style.justifyContent = "center";
      if(item.shape==="circle"){
        const d = document.createElement("div");
        d.style.width = sz+"px";
        d.style.height = sz+"px";
        d.style.background = color;
        d.style.borderRadius = "50%";
        d.style.boxShadow = "0 10px 30px rgba(0,0,0,0.35)";
        shapeContainer.appendChild(d);
      } else if(item.shape==="square"){
        const d = document.createElement("div");
        d.style.width=sz+"px"; d.style.height=sz+"px"; d.style.background=color; d.style.borderRadius="10px";
        d.style.boxShadow="0 10px 30px rgba(0,0,0,0.35)";
        shapeContainer.appendChild(d);
      } else { // triangle
        const d = document.createElement("div");
        const side = sz;
        d.style.width="0"; d.style.height="0";
        d.style.borderLeft=(side/2)+"px solid transparent";
        d.style.borderRight=(side/2)+"px solid transparent";
        d.style.borderBottom=side+"px solid "+color;
        d.style.transform="translateY(6px)";
        shapeContainer.appendChild(d);
      }
      cell.appendChild(shapeContainer);
    }
    // Build relation buttons
    const relationBar = $("#relationBar");
    function buildRelationButtons(relations){
      relationBar.innerHTML="";
      relations.forEach((rel, idx)=>{
        const btn = document.createElement("button");
        btn.className="rel-btn kbd";
        btn.dataset.rel = rel;
        btn.setAttribute("data-key", String((idx+1)%10 || 0));
        btn.setAttribute("aria-label", `Relation button for ${rel}`);
        // Title for composite reads "Composite"
        btn.innerHTML = `<span class="title">${rel.charAt(0).toUpperCase()+rel.slice(1)}</span>`;
        const sub = document.createElement("span"); sub.className="sub"; sub.textContent="...";
        btn.appendChild(sub);
        btn.addEventListener("click", ()=> tryRespond(rel));
        relationBar.appendChild(btn);
      });
    }
    // State
    const VERSION = "1.3";
    const state = {
      running:false,
      seq:[],
      prompts:{},
      i:-1,
      n:1,
      len:24,
      relations:["position","sound","color","shape"], // composite added via toggle
      matchRatio:33,
      lurePct:45,
      strictWindow:false,
      windowOpen:false,
      responses:[],
      score:0,
      streak:0,
      trialStartTs: 0,
      respondedThisTrial: new Set(),
      perModStats: {}, // {rel:{hits,misses,fa,cr,rts:[]}}
      jitterOn:true,
      adaptiveOn:false,
      seed: null,
      showFeedback: true
    };
    // Controls
    const nLevel = $("#nLevel");
    const stimMs = $("#stimMs");
    const isiMs = $("#isiMs");
    const len = $("#len");
    const matchRatio = $("#matchRatio");
    const lurePct = $("#lurePct");
    const dynamicLabels = $("#dynamicLabels");
    const strictWindow = $("#strictWindow");
    const jitterOn = $("#jitterOn");
    const adaptiveOn = $("#adaptiveOn");
    const soundOn = $("#soundOn");
    const voiceOn = $("#voiceOn");
    const colorblind = $("#colorblind");
    const showFeedback = $("#showFeedback");
    const progressBar = $("#progressBar");
    const progressText = $("#progressText");
    const nLabel = $("#nLabel");
    const scoreEl = $("#score");
    const accEl = $("#acc");
    const streakEl = $("#streak");
    const trialCounter = $("#trialCounter");
    const startBtn = $("#startBtn");
    const stopBtn = $("#stopBtn");
    const undoBtn = $("#undoBtn");
    const backBtn = $("#backBtn");
    const stepBtn = $("#stepBtn");
    const seedBtn = $("#seedBtn");
    const passBtn = $("#passBtn");
    const hintBtn = $("#hintBtn");
    const repeatBtn = $("#repeatBtn");
    const clearBtn = $("#clearBtn");
    const exportBtn = $("#exportBtn");
    const resetBtn = $("#resetBtn");
    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
    function parseRelationsField(){
      // COMPOSITE: include if toggled
      return ["position","sound","color","shape","composite"].filter(r => $(`#mod-${r}`)?.checked);
    }
    function ensureModStats(){
      state.relations.forEach(rel=>{
        if(!state.perModStats[rel]) state.perModStats[rel] = {hits:0, misses:0, fa:0, cr:0, rts:[]};
      });
    }
    function refreshConfig(){
      state.n = clamp(parseInt(nLevel.value)||1,1,9);
      state.len = clamp(parseInt(len.value)||24, 8, 300);
      state.matchRatio = clamp(parseInt(matchRatio.value)||33, 0, 90);
      state.lurePct = clamp(parseInt(lurePct.value)||45, 0, 70);
      state.relations = parseRelationsField();
      state.strictWindow = strictWindow.checked;
      state.jitterOn = jitterOn.checked;
      state.adaptiveOn = adaptiveOn.checked;
      state.showFeedback = showFeedback.checked;
      if(colorblind.checked && state.relations.includes("color")) {
        log("Colorblind mode on: Consider removing 'color' from modalities for better experience.");
        if(!voiceOn.checked) voiceOn.checked = true; // Auto-enable voice
        COLORS = ["#ffffff", "#333333"];
      } else {
        COLORS = ["#e69f00", "#56b4e9", "#009e73", "#f0e442", "#0072b2"];
      }
      nLabel.textContent = state.n;
    }
    function saveSettings(){
      localStorage.setItem("rnback_settings", JSON.stringify({
        nLevel: nLevel.value,
        stimMs: stimMs.value,
        isiMs: isiMs.value,
        len: len.value,
        modPosition: $("#mod-position").checked,
        modSound: $("#mod-sound").checked,
        modColor: $("#mod-color").checked,
        modShape: $("#mod-shape").checked,
        // COMPOSITE: persist toggle
        modComposite: $("#mod-composite").checked,
        // END COMPOSITE
        matchRatio: matchRatio.value,
        lurePct: lurePct.value,
        dynamicLabels: dynamicLabels.checked,
        strictWindow: strictWindow.checked,
        jitterOn: jitterOn.checked,
        adaptiveOn: adaptiveOn.checked,
        soundOn: soundOn.checked,
        voiceOn: voiceOn.checked,
        colorblind: colorblind.checked,
        showFeedback: showFeedback.checked
      }));
    }
    function loadSettings(){
      const saved = localStorage.getItem("rnback_settings");
      if(saved){
        const d = JSON.parse(saved);
        nLevel.value = d.nLevel || 1;
        stimMs.value = d.stimMs || 1300;
        isiMs.value = d.isiMs || 300;
        len.value = d.len || 24;
        $("#mod-position").checked = d.modPosition ?? true;
        $("#mod-sound").checked = d.modSound ?? true;
        $("#mod-color").checked = d.modColor ?? true;
        $("#mod-shape").checked = d.modShape ?? true;
        // COMPOSITE: restore toggle (default off)
        $("#mod-composite").checked = d.modComposite ?? false;
        // END COMPOSITE
        matchRatio.value = d.matchRatio || 33;
        lurePct.value = d.lurePct || 45;
        dynamicLabels.checked = d.dynamicLabels ?? true;
        strictWindow.checked = d.strictWindow ?? false;
        jitterOn.checked = d.jitterOn ?? true;
        adaptiveOn.checked = d.adaptiveOn ?? false;
        soundOn.checked = d.soundOn ?? true;
        voiceOn.checked = d.voiceOn ?? false;
        colorblind.checked = d.colorblind ?? false;
        showFeedback.checked = d.showFeedback ?? true;
      }
      refreshConfig();
    }
    function toggleManualControls(show) {
      $(".manual-controls").style.display = show ? "flex" : "none";
    }
    function newSequence(){
      refreshConfig();
      reseed();
      state.seq = Array.from({length: state.len}, ()=> generateItem());
      state.prompts = generatePromptsAndAdjust(state.seq, state.relations, state.n, state.matchRatio, state.lurePct);
      state.i = -1;
      state.responses = [];
      state.score = 0;
      state.streak = 0;
      state.perModStats = {};
      ensureModStats();
      scoreEl.textContent = "0";
      streakEl.textContent = "0";
      accEl.textContent = "100%";
      progress(0);
      buildRelationButtons(state.relations);
      updateRelationButtons();
      clearCells();
      renderMetrics();
      trialCounter.textContent = "0";
      log(`Sequence generated: len=${state.len}, N=${state.n}, rels=${state.relations.join("+")}, true≈${state.matchRatio}%, lure≈${state.lurePct}%, seed=${state.seed}`);
    }
    function progress(idx){
      progressText.textContent = `${idx} / ${state.len}`;
      progressBar.style.width = `${Math.round(idx/state.len*100)}%`;
      trialCounter.textContent = String(idx);
    }
    function openWindow(){ state.windowOpen = true; if(soundOn.checked) sfx.tick(); updateRelationButtons(); }
    function closeWindow(){ state.windowOpen = false; updateRelationButtons(); }
    function present(i, withAudio=true){
      drawStimulus(state.seq[i]);
      if(withAudio && soundOn.checked){
        const letter = state.seq[i].sound;
        const map = {A:440,B:494,C:523,D:587,E:659};
        tone(map[letter] || 392, 0.09, "sine", 0.04);
      }
      if(voiceOn.checked && 'speechSynthesis' in window){
        const utt = new SpeechSynthesisUtterance();
        utt.text = `Position ${posIndex(state.seq[i].position)}. Sound ${state.seq[i].sound}. Color ${state.seq[i].color.slice(1)}. Shape ${state.seq[i].shape}.`;
        utt.rate = 1.2;
        utt.volume = 1;
        setTimeout(()=> speechSynthesis.speak(utt), 100);
      }
    }
    function relationIsTrue(rel, i){
      const n = state.n;
      if(i < n) return false;
      // COMPOSITE: handle separately
      if(rel === "composite"){
        const operator = state.prompts.composite?.[i];
        if(!operator) return false;
        const baseRelations = state.relations.filter(r => r !== "composite");
        return Eval.composite(operator, i, n, baseRelations);
      }
      const prompt = state.prompts[rel][i];
      if(!prompt) return false;
      const cur = state.seq[i][rel];
      const prev = state.seq[i-n][rel];
      return Eval[rel](prompt, cur, prev);
    }
    function updateRelationButtons(){
      const i = state.i;
      state.relations.forEach((rel, idx)=>{
        const btn = relationBar.querySelector(`.rel-btn[data-rel="${rel}"]`);
        if(!btn) return;
        btn.querySelector(".title").textContent = rel.charAt(0).toUpperCase()+rel.slice(1);
        const sub = btn.querySelector(".sub");
        let promptText = "...";
        if(dynamicLabels.checked){
          const prompt = state.prompts[rel]?.[i] ?? pick(PROMPTS[rel]);
          // COMPOSITE: show operator and span info
          if(rel === "composite" && prompt){
            sub.textContent = `${prompt} over ${state.n+1} trials`;
          } else {
            sub.textContent = prompt || "...";
          }
          sub.style.display = "inline-block";
          promptText = sub.textContent;
        }else{
          sub.textContent = "";
          sub.style.display = "none";
        }
        btn.setAttribute("aria-label", `Press for ${rel} if ${promptText}`);
        btn.classList.remove("matching","pending");
        const isTrue = relationIsTrue(rel, i);
        if(isTrue && !state.windowOpen && state.showFeedback){
          btn.classList.add("matching");
          if(state.strictWindow){
            btn.classList.add("pending");
          }
        }
        btn.setAttribute("data-key", String((idx+1)%10 || 0));
      });
    }
    function calcAccuracy(){
      const judged = state.responses.filter(r => r.kind!=="pre");
      if(!judged.length) return 100;
      const hits = judged.filter(r=>r.hit).length;
      return Math.round((hits/judged.length)*100);
    }
    // SDT helpers
    function erfinv(x){
      const a = 0.147;
      const ln = Math.log(1 - x*x);
      const s = (2/(Math.PI*a) + ln/2);
      const sign = x < 0 ? -1 : 1;
      return sign * Math.sqrt( Math.sqrt( s*s - ln/a ) - s );
    }
    function zOf(p){
      const pp = Math.min(1-1e-10, Math.max(1e-10, p));
      return Math.SQRT2 * erfinv(2*pp - 1);
    }
    function dPrimeFor(rel){
      const s = state.perModStats[rel] || {hits:0,misses:0,fa:0,cr:0};
      const Hn = s.hits + s.misses;
      const Fn = s.fa + s.cr;
      if(!Hn || !Fn) return {d:0, c:0};
      const pHit = Math.min(1-1/(2*Hn), Math.max(1/(2*Hn), s.hits/Hn));
      const pFA = Math.min(1-1/(2*Fn), Math.max(1/(2*Fn), s.fa/Fn));
      const zH = zOf(pHit), zF = zOf(pFA);
      const d = zH - zF;
      const c = -0.5*(zH + zF);
      return {d, c};
    }
    function renderMetrics(){
      ensureModStats();
      const rows = state.relations.map(rel=>{
        const {d,c} = dPrimeFor(rel);
        const s = state.perModStats[rel];
        const Hn = s.hits + s.misses;
        const Fn = s.fa + s.cr;
        const missRate = Hn ? (s.misses / Hn * 100).toFixed(0) : 0;
        const faRate = Fn ? (s.fa / Fn * 100).toFixed(0) : 0;
        const rts = state.perModStats[rel].rts.slice().sort((a,b)=>a-b);
        const medianRt = rts.length ? rts[Math.floor(rts.length/2)] : 0;
        return `${rel.padEnd(9)} d'=${d.toFixed(2)} c=${c.toFixed(2)} FA=${faRate}% Miss=${missRate}% RT≈${medianRt}ms`;
      });
      metricsEl.textContent = rows.join("\n");
    }
    function updateSdt(rel, hit, i, rt){
      ensureModStats();
      const isSignal = relationIsTrue(rel, i);
      const s = state.perModStats[rel];
      if(isSignal && hit) s.hits++; else if(isSignal && !hit) s.misses++;
      if(!isSignal && hit) s.fa++; else if(!isSignal && !hit) s.cr++;
      if(Number.isFinite(rt)) s.rts.push(rt);
    }
    function tryRespond(rel){
      if(state.strictWindow && !state.windowOpen){ if(soundOn.checked) sfx.err(); return; }
      if(!state.running && state.i<0){ log("Start the session to respond."); return; }
      if(state.respondedThisTrial.has(rel)) return;
      state.respondedThisTrial.add(rel);
      const i = state.i;
      const hit = relationIsTrue(rel, i);
      const rt = performance.now() - state.trialStartTs;
      state.responses.push({i, rel, hit, ts: performance.now(), rt, kind:"rel"});
      if(hit){ state.score += 1; state.streak += 1; if(soundOn.checked) sfx.ok(); }
      else { state.streak = 0; if(soundOn.checked) sfx.err(); }
      scoreEl.textContent = String(state.score);
      streakEl.textContent = String(state.streak);
      accEl.textContent = `${calcAccuracy()}%`;
      updateSdt(rel, hit, i, rt);
      renderMetrics();
      const btn = relationBar.querySelector(`.rel-btn[data-rel="${rel}"]`);
      if(btn && state.showFeedback){
        if(hit) btn.classList.add("matching");
        btn.animate([{transform:"scale(1)"},{transform:"scale(0.96)"},{transform:"scale(1)"}], {duration:120});
      }
      ariaAnnounce.textContent = hit ? "Correct" : "Incorrect";
      if("vibrate" in navigator) navigator.vibrate(10);
      log(`${hit? "HIT":"MISS"} on ${rel} with prompt "${state.prompts[rel][i] || "?"}" @ t=${i} (N=${state.n}) RT=${Math.round(rt)}ms`);
    }
    function respondNoMatch(){
      const i = state.i;
      const anyTrue = state.relations.some(rel=> relationIsTrue(rel, i));
      const hit = !anyTrue;
      state.responses.push({i, rel:"none", hit, ts: performance.now(), kind:"none"});
      if(hit){ state.score += 1; state.streak += 1; if(soundOn.checked) sfx.ok(); }
      else { state.streak = 0; if(soundOn.checked) sfx.err(); }
      scoreEl.textContent = String(state.score);
      streakEl.textContent = String(state.streak);
      accEl.textContent = `${calcAccuracy()}%`;
      renderMetrics();
      log(`${hit? "Correct":"Incorrect"} "No match" @ t=${i}`);
    }
    // Loop
    let stepTimeout = null;
    const jitterFn = (v)=> {
      if(!state.jitterOn) return v;
      const band = v < 500 ? 0.1 : 0.2;
      const minF = 1 - band, maxF = 1 + band;
      return Math.max(100, Math.round(v * (minF + rng() * (maxF - minF))));
    };
    function runLoop(){
      if(!state.running) return;
      state.i += 1;
      const i = state.i;
      if(i >= state.seq.length){ finish(); return; }
      progress(i);
      present(i);
      state.respondedThisTrial.clear();
      state.trialStartTs = performance.now();
      openWindow();
      const baseStim = clamp(parseInt(stimMs.value)||1300, 200, 4000);
      const baseGap = clamp(parseInt(isiMs.value)||300, 0, 4000);
      const stimDuration = jitterFn(baseStim);
      const gapDuration = jitterFn(baseGap);
      clearTimeout(stepTimeout);
      setTimeout(()=>{
        closeWindow();
        if(gapDuration>0){
          stepTimeout = setTimeout(()=> { maybeAdaptPeriodic(); runLoop(); }, gapDuration);
        }else{
          maybeAdaptPeriodic(); runLoop();
        }
      }, stimDuration);
      updateRelationButtons();
    }
    function finish(){
      state.running = false;
      toggleManualControls(true);
      startBtn.disabled = false;
      stopBtn.disabled = true;
      undoBtn.disabled = false;
      stepBtn.disabled = false;
      backBtn.disabled = false;
      passBtn.disabled = true;
      renderMetrics();
      log(`Finished. Score=${state.score} Acc=${calcAccuracy()}%`);
      maybeAdapt(true);
    }
    function start(){
      if(state.running) return;
      audio.resume?.();
      refreshConfig();
      if(state.seq.length !== state.len) newSequence();
      state.running = true;
      toggleManualControls(false);
      startBtn.disabled = true;
      stopBtn.disabled = false;
      undoBtn.disabled = true;
      stepBtn.disabled = true;
      backBtn.disabled = true;
      passBtn.disabled = false;
      runLoop();
      log("Started.");
    }
    function stop(){
      state.running = false;
      toggleManualControls(true);
      clearTimeout(stepTimeout);
      closeWindow();
      startBtn.disabled = false;
      stopBtn.disabled = true;
      undoBtn.disabled = false;
      stepBtn.disabled = false;
      backBtn.disabled = false;
      passBtn.disabled = true;
      renderMetrics();
      log("Stopped.");
    }
    function stepOnce(){
      if(state.running) return;
      state.i += 1;
      if(state.i >= state.seq.length){
        log("Reached end. Reseed or restart.");
        state.i = state.seq.length - 1;
        return;
      }
      progress(state.i);
      present(state.i);
      state.respondedThisTrial.clear();
      state.trialStartTs = performance.now();
      openWindow();
      clearTimeout(stepTimeout);
      stepTimeout = setTimeout(()=> closeWindow(), 900);
      sfx.cue();
      updateRelationButtons();
    }
    function backOnce(){
      if(state.running) return;
      if(state.i <= 0){
        log("At beginning. Cannot go back.");
        return;
      }
      state.i -= 1;
      progress(state.i);
      present(state.i, true);
      state.respondedThisTrial.clear();
      closeWindow();
      updateRelationButtons();
      log(`Reviewed back @ t=${state.i} (no scoring/response)`);
    }
    function undo(){
      const last = state.responses.pop();
      if(!last){ log("Nothing to undo."); return; }
      recomputeScore();
      renderMetrics();
      log(`Undid response @ t=${last.i} (${last.rel})`);
    }
    function recomputeScore(){
      state.score = 0; state.streak = 0;
      state.responses.forEach(r=>{
        if(r.hit){ state.score += 1; state.streak += 1; } else { state.streak = 0; }
      });
      scoreEl.textContent = String(state.score);
      streakEl.textContent = String(state.streak);
      accEl.textContent = `${calcAccuracy()}%`;
    }
    function peek(){
      const i = state.i;
      const n = state.n;
      if(i < n){ log("Peek: Not enough history yet."); return; }
      const truths = state.relations
        .filter(rel => relationIsTrue(rel, i))
        .map(rel => `${rel}:${state.prompts[rel][i]}`);
      log(`Peek @ t=${i}: ${truths.length? truths.join(" | "): "no prompts true"}`);
    }
    function repeatStim(){
      if(state.i < 0) return;
      present(state.i);
      openWindow();
      updateRelationButtons();
    }
    function clearPrompts(){
      dynamicLabels.checked = false;
      updateRelationButtons();
      log("Dynamic prompts disabled.");
    }
    // Adaptive N (unchanged)
    function maybeAdapt(force=false){
      if(!state.adaptiveOn) return;
      const sampled = state.relations.map(rel => ({rel, ...dPrimeFor(rel)}));
      if(!sampled.length) return;
      sampled.sort((a,b)=> a.d - b.d);
      const weak = sampled[0];
      const s = state.perModStats[weak.rel];
      const Hn = s.hits + s.misses;
      const Fn = s.fa + s.cr;
      if(Hn < 40 || Fn < 40) return;
      const dTarget = 1.1;
      const faRate = Fn ? s.fa / Fn : 0;
      const canIncrease = weak.d > dTarget && faRate <= 0.15 && weak.c < 0.5;
      const shouldDecrease = weak.d < dTarget*0.6 || weak.c > 0.5;
      let changed = false;
      if(canIncrease && state.n < 9){ state.n += 1; changed = true; }
      else if(shouldDecrease && state.n > 1){ state.n -= 1; changed = true; }
      if(changed){
        nLabel.textContent = state.n;
        log(`Adaptive N: ${canIncrease? "↑" : "↓"} N=${state.n} (weak=${weak.rel}, d'=${weak.d.toFixed(2)}, FA=${(faRate*100).toFixed(0)}%, bias c=${weak.c.toFixed(2)})`);
      } else if(force){
        log(`Adaptive check: no change (weak=${weak.rel}, d'=${weak.d.toFixed(2)})`);
      }
    }
    function maybeAdaptPeriodic(){
      if(!state.adaptiveOn) return;
      if(state.i>0 && state.i % 8 === 0) maybeAdapt();
    }
    // Keyboard
    document.addEventListener("keydown", (e)=>{
      if(e.target && ["INPUT","TEXTAREA","SELECT"].includes(e.target.tagName)) return;
      if(e.code==="Space"){
        e.preventDefault();
        if(state.running) stop(); else start();
        return;
      }
      if(e.key.toLowerCase()==="n"){ e.preventDefault(); respondNoMatch(); return; }
      if(e.key === "?") {
        e.preventDefault();
        const h = $("#helpOverlay");
        h.style.display = h.style.display === "none" ? "block" : "none";
        return;
      }
      const k = e.key;
      const btn = $(`.rel-btn[data-key="${k}"]`);
      if(btn){ e.preventDefault(); tryRespond(btn.dataset.rel); }
    });
    // Wire controls
    strictWindow.addEventListener("change", ()=>{ state.strictWindow = strictWindow.checked; updateRelationButtons(); saveSettings(); });
    soundOn.addEventListener("change", ()=>{ if(soundOn.checked) sfx.cue(); saveSettings(); });
    dynamicLabels.addEventListener("change", ()=> { updateRelationButtons(); saveSettings(); });
    jitterOn.addEventListener("change", ()=>{ state.jitterOn = jitterOn.checked; saveSettings(); });
    adaptiveOn.addEventListener("change", ()=>{ state.adaptiveOn = adaptiveOn.checked; saveSettings(); });
    voiceOn.addEventListener("change", saveSettings);
    colorblind.addEventListener("change", ()=>{ saveSettings(); refreshConfig(); newSequence(); });
    showFeedback.addEventListener("change", ()=>{ state.showFeedback = showFeedback.checked; saveSettings(); });
    ["position","sound","color","shape","composite"].forEach(mod => {
      $(`#mod-${mod}`).addEventListener("change", () => {
        if(state.running) return;
        buildRelationButtons(parseRelationsField());
        newSequence();
        saveSettings();
      });
    });
    startBtn.onclick = start;
    stopBtn.onclick = stop;
    stepBtn.onclick = stepOnce;
    backBtn.onclick = backOnce;
    undoBtn.onclick = undo;
    seedBtn.onclick = ()=>{ reseed(); newSequence(); };
    passBtn.onclick = respondNoMatch;
    hintBtn.onclick = peek;
    repeatBtn.onclick = repeatStim;
    clearBtn.onclick = clearPrompts;
    exportBtn.onclick = ()=>{
      let csv = "version,seed,i,N,modality,prompt,role,response,hit,RT,windowType,stimMs,isiMs,multiTrue\n";
      const responsesByTrial = state.responses.reduce((acc,r)=>{
        if(!acc[r.i]) acc[r.i] = [];
        acc[r.i].push(r);
        return acc;
      },{});
      for(let i=0; i<state.len; i++){
        state.relations.forEach(rel=>{
          const prompt = state.prompts[rel]?.[i] || "";
          // COMPOSITE: role is DERIVED; others as before
          const role = state.seq[i]?._trial?.[rel]?.role || (rel==="composite" ? "DERIVED" : "");
          const resp = responsesByTrial[i]?.find(r => r.rel === rel);
          const response = resp ? "yes" : "no";
          const hit = resp ? resp.hit : "";
          const rt = resp ? Math.round(resp.rt) : "";
          const multiTrue = state.seq[i]?.multiTrue ? 1 : 0;
          csv += `${VERSION},${state.seed},${i},${state.n},${rel},${prompt},${role},${response},${hit},${rt},${state.strictWindow ? "strict" : "open"},${stimMs.value},${isiMs.value},${multiTrue}\n`;
        });
      }
      const blob = new Blob([csv], {type: "text/csv"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `rnback_${new Date().toISOString().slice(0,10)}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    };
    resetBtn.onclick = ()=>{ localStorage.removeItem("rnback_settings"); location.reload(); };
    [nLevel, stimMs, isiMs, len, matchRatio, lurePct].forEach(el=>{
      el.addEventListener("change", ()=>{
        if(state.running) return;
        newSequence();
        saveSettings();
      });
    });
    // Init
    loadSettings();
    toggleManualControls(true);
    reseed();
    newSequence();
    // Expose for console
    window.RNBack = { state, newSequence, start, stop, stepOnce, backOnce, reseed };
  </script>
</body>
</html>

